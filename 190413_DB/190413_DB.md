#  데이터베이스(기초)
## 하석재 강사님 / 2HCUBE, CEO
### 2019.04.13.

---

### RBMS(인덱스)
- 테이블 -> 인덱스 -> 파티셔닝 -> 샤딩
- 인덱스를 달아도 성능이 느릴 정도가 되면 어떻게 해야할까?
    - 데이터가 너무 많으면 인덱스를 달아도 속도가 느려짐
    - ex) 페이스북은 하루에 데이터가 약 10TB가 쌓임

### 파티셔닝(Partitioning)
- 인덱스가 달더라도 데이터가 많아지면 검색이 느려지는 문제를 해결하기 위함
- 워킹셋
    - 현재 엑티브한 레코드들의 모임
- 한번에 검색하는 것보다 일부를 쪼개서 검색하는 것이 더 빠를 것임
- 전체 데이터를 보지 않고 특정 데이터 구간만 보더라 라는 아이디어에서 시작

```sql
# 파티션 만들어보기
CREATE TABLE `employees_new` (
  `emp_no` int(11) NOT NULL,
  `birth_date` date NOT NULL,
  `first_name` varchar(14) NOT NULL,
  `last_name` varchar(16) NOT NULL,
  `gender` enum('M','F') NOT NULL,
  `hire_date` date NOT NULL
) ENGINE=InnoDB
PARTITION BY RANGE(YEAR(hire_date)) (
partition p0 values less than (1991),
partition p1 values less than (1996),
partition p2 values less than (2001),
partition p3 values less than MAXVALUE
);
```

- 검색/업데이트에 유리
- DBMS 자체에서 지원해주는 기능
- 많이 쪼개면 좋음?
    - 무조건 좋아지는 것은 아님
    - 많이 쪼개지면 특정 구간에서부터 성능이 떨어지기 시작함
    - 최적의 파티션 수를 찾는 문제가 있음
- 파티션 테이블의 결정 기준
    - 파티션 키 + 인덱스 사용 여부

#### 파티션 종류
- Range 파티션
    - 정해전 범위로 구분
- List 파티션
    - 이산된 값에 따라 파티션 구분
    - 봄, 여름, 가을, 겨울
- Hash 파티션
    - 해시값에 따른 파티션 구분
    - 파티션별로 일정한 크기로 구분
    - 변경이 힘들다는 단점
    - 보증된 데이터 양에 최적
- 키 파티션
    - 컬럼을 정해서 해시 파티션

#### 파티션
- 제약조건
    - 동일한 스토리지 엔진
    - 최대 1024개의 파티션
    - 외래키 사용불가 -> 조인이 불가능함

- 정규화 vs. 역정규화(중복허용)
    - 정규화는 기본적으로 허용
    - 조인이 안되는 파티션과 샤딩에서는 중복을 허용해야하므로 역정규화를 허용

### 샤딩
- 데이터가 지나치게 많아지면 하나의 시스템으로 저장이 힘들어지는 상황
- 파티셔닝과 개념은 유사하지만 시스템을 쪼개는 것
- 어느 서버에 데이터가 들어있는지 알고 있어야하는 문제가 추가됨
- DBMS 외부 플랫폼이 지원해주는 방법(물리적 분할)
- 파티셔닝과 다르게 쪼갤수록 성능이 좋아짐
- 수직 샤딩 vs. 수평 샤딩
    - 수평 샤딩 : 내용만 다를 뿐, 스키마는 동일
    - 수직 샤딩 : 스키마가 다름
    - 스키마를 기준으로 나눔
- 쓰기 성능을 지속적으로 향상시킬 수 있음

### 복제
- 내용의 동일한 DBMS를 여러 개 만드는 기술
    - DB 이중화 라고 불리는 것
    - DB는 이중화가 없음..
- 읽기 성능을 지속적으로 향상 기능
- 서버가 일부 죽더라도 서비스는 계속 동작
    - 고가용성(HA: High Availability)
    - 시스템은 죽지만 서비스는 죽으면 안됨
    - 문제 생기면 보완하는 기술?
        - 실제로는 성능을 높이는 용도로 사용
- 샤딩과 복제는 평상시에도 사용
    - 문제가 생긴다고 사용하는 것이 아님
    - 그냥 사용해도 그만한 장점이 있기 때문
- 읽기 성능을 지속적으로 향상시킬 수 있음
- 좋은 기능이지만 제일 비쌈
    - 오라클 기준으로 복제 수 만큼 라이센스 필요
        - 오라클 RAC, 가격은 40,000불
    - 다른 무료 DBMS(MySQL, MariaDB)를 사용해서 구축하는 경우가 많음 
- 슬레이브 수는 8~10개가 최대
    - 그 이상의 경우 마스터의 성능이 떨어짐
    - 슬레이브를 추가하기 위해서는 유저를 추가해주면 됨

#### 복제 종류
- 마스터/슬레이브 복제
    - 마스터에 쓰고, 슬레이브에서 복제 및 읽기
- 액티브/액티브 복제
    - 마스터와 슬레이브를 구분하지 않고, 어느 쪽에 기록해도 반양됨
    - 액티브가 다운되는 경우에도 동작
    - 블록체인 기술과 유사

#### 복제 방법
- Statement-based 복제
    - SQL 쿼리를 복제해서 슬레이브에 전달
    - 같은 SQL 문장을 이용했지만, 서로 다른 결과가 나오는 경우가 있음
        - timestamp를 이용한 결과, 랜덤값을 이용한 결과
- Row-based 복제
    - SQL을 실행해서 변경된 라인을 보내서 전송하는 방법
    - 변화되는 문장이 많아지면 Traffic 문제가 발생할 수 있음
- Mixed 복제
    - 두가지 방법을 모두 사용
    - 기본적으로 Statement 복제를 하고, 같은 결과가 나오지 않는 경우에는 Row기반 복제를 사용함

- 실제로는 Row-based 복제를 추천함

#### MySQL/MariaDB 로그 파일의 종류
- Error Log
- General Log
- Slow Query Log
- **Binary Log**
    - 복제용 / 마스터
    - 마스터에서 Binary Log에 남기면 슬레이브에서 복제해감
- **Relay log**
    - 복제용 / 슬레이브
    - 마스터에서 Binary Log를 복제해온 것
- Audit Log
    - 엔터프라이즈 버전에만 있음
    - 시스템이 잘 돌아가는지 확인하는 로그

#### 복제 과정
- Slave IO 쓰레드
    - 마스터 DBMS에 로그인해서 바이너리 로그를 읽어 릴레이로그에 쓰는 쓰레드
- Slave SQL 쓰레드
    - 릴레이로그에서 실제 블레이브 DBMS에 반영하는 쓰레드

#### 복제와 샤딩
- 읽기 쓰기를 동시에 할 수 있는 방법은?
    - 샤딩을 통해 나눔
    - 개별 샤드를 N개로 복제

### 트랜잭션
- 일관성(Consistency)
    - 한 데이터의 버전은 하나뿐임 / 여러 개를 인정하지 않음
    - 복제나 백업과 같은 긴 트랜잭션시 문제가 됨
    - 복제나 백업을 했으나 두개가 서로 다른 경우 일관성이 깨짐
    - 블록체인에서는 일관성이 깨지는 부분이 생김
- 격리 수준(Isolation Level)
    - Read Uncommitted
        - 확정되지 않은 값을 찍음
    - Read Committed
        - 확정된 값을 찍음
    - Serialization
        - 일관성이 깨지는 일이 없도록 트랜잭션이 한 번에 하나씩만 실행
        - 멀티 Thread를 사용하는 이유가 사라지기에 잘 사용하지 않음
    - Repeatable Read
        - 트랜잭션이 시작되고 읽은 값은 종료될 때까지 동일한 값을 리턴
        - 오래 실행되는 트랜잭션에서 사용하는 경우(복제, 백업)

---
- 복제 실습 <https://jupiny.com/2017/11/07/docker-mysql-replicaiton/>